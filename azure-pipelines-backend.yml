trigger:
  branches:
    include:
    - main
    - master
  paths:
    include:
    - api.py
    - query_rag.py
    - config.py
    - pdf_generator.py
    - requirements.txt
    - Dockerfile
    - chunked_output/**
    - case_id_to_s3_mapping.json
    - azure-pipelines-backend.yml

variables:
  acrName: 'legalragpersonalacr'
  imageName: 'legal-rag-api'
  resourceGroup: 'legal-rag-personal-rg'
  aksCluster: 'legal-rag-personal-aks'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  azureSubscription: 'Azure-Personal-SC'  # Service connection name - you'll create this

pool:
  name: 'Default'  # Self-hosted Windows agent with aggressive memory optimization

stages:
- stage: Build
  displayName: 'Build and Push Docker Image'
  jobs:
  - job: BuildJob
    displayName: 'Build and Push Image'
    timeoutInMinutes: 180  # 3 hours timeout
    steps:
    - task: PowerShell@2
      displayName: 'Aggressive Memory Cleanup'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Aggressive Docker Cleanup ==="

          # Stop all running containers
          Write-Host "Stopping all containers..."
          docker ps -q | ForEach-Object { docker stop $_ }

          # Remove all stopped containers
          Write-Host "Removing stopped containers..."
          docker container prune -f

          # Remove dangling images
          Write-Host "Removing dangling images..."
          docker image prune -f

          # Remove unused images (keep only last 2 versions)
          Write-Host "Removing old images..."
          docker images --filter "reference=legalragpersonalacr.azurecr.io/legal-rag-api" --format "{{.ID}}" | Select-Object -Skip 2 | ForEach-Object { docker rmi -f $_ }

          # Remove build cache
          Write-Host "Removing build cache..."
          docker builder prune -f

          # System-wide cleanup
          Write-Host "System-wide cleanup..."
          docker system prune -af --volumes

          # Show current status
          Write-Host "`n=== Docker Status ==="
          docker system df

          Write-Host "`n=== Memory Status ==="
          Get-WmiObject Win32_OperatingSystem | Select-Object @{Name="FreeMemoryGB";Expression={[math]::Round($_.FreePhysicalMemory/1MB,2)}}, @{Name="TotalMemoryGB";Expression={[math]::Round($_.TotalVisibleMemorySize/1MB,2)}}

          Write-Host "`nCleanup complete!"

    - task: AzureCLI@2
      displayName: 'Login to ACR'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        inlineScript: |
          chcp 65001
          az acr login --name $(acrName)

    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        tags: |
          $(Build.BuildId)
          latest
        arguments: '-t $(acrName).azurecr.io/$(imageName):$(Build.BuildId) -t $(acrName).azurecr.io/$(imageName):latest'

    - task: AzureCLI@2
      displayName: 'Push Build ID Tag to ACR'
      timeoutInMinutes: 120  # 2 hours for push
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        inlineScript: |
          $ErrorActionPreference = "Continue"

          Write-Host "Starting push of tag $(Build.BuildId)..."
          Write-Host "This may take a long time for large images. Please be patient."

          # Push with timeout handling
          $job = Start-Job -ScriptBlock {
            docker push legalragpersonalacr.azurecr.io/legal-rag-api:$using:env:BUILD_BUILDID 2>&1
          }

          $timeout = 7200  # 2 hours in seconds
          $elapsed = 0
          $reportInterval = 60  # Report every minute

          while ($job.State -eq 'Running' -and $elapsed -lt $timeout) {
            Start-Sleep -Seconds $reportInterval
            $elapsed += $reportInterval
            $minutes = [math]::Round($elapsed / 60, 1)
            Write-Host "Still pushing... ($minutes minutes elapsed)"
          }

          if ($job.State -eq 'Running') {
            Stop-Job $job
            Remove-Job $job
            throw "Push timed out after $($timeout/60) minutes"
          }

          $result = Receive-Job $job
          Remove-Job $job

          Write-Host $result
          Write-Host "Successfully pushed tag $(Build.BuildId)"

    - task: AzureCLI@2
      displayName: 'Push Latest Tag to ACR'
      timeoutInMinutes: 30  # Latest should be faster since layers exist
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        inlineScript: |
          Write-Host "Pushing latest tag (reusing layers from previous push)..."
          docker push $(acrName).azurecr.io/$(imageName):latest

    - task: PowerShell@2
      displayName: 'Cleanup After Push'
      condition: always()  # Run even if previous steps failed
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Post-Push Cleanup ==="

          # Remove the images we just pushed to free memory immediately
          Write-Host "Removing pushed images from local cache..."
          docker rmi -f $(acrName).azurecr.io/$(imageName):$(Build.BuildId) 2>$null
          docker rmi -f $(acrName).azurecr.io/$(imageName):latest 2>$null

          # Quick prune
          docker image prune -f

          Write-Host "`n=== Final Memory Status ==="
          Get-WmiObject Win32_OperatingSystem | Select-Object @{Name="FreeMemoryGB";Expression={[math]::Round($_.FreePhysicalMemory/1MB,2)}}, @{Name="TotalMemoryGB";Expression={[math]::Round($_.TotalVisibleMemorySize/1MB,2)}}

- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployJob
    displayName: 'Deploy to AKS'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Deploy to AKS'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'ps'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get AKS credentials
                az aks get-credentials `
                  --resource-group $(resourceGroup) `
                  --name $(aksCluster) `
                  --overwrite-existing

                # Update deployment image
                kubectl set image deployment/legal-rag-api `
                  api=$(acrName).azurecr.io/$(imageName):$(Build.BuildId)

                # Wait for rollout to complete
                kubectl rollout status deployment/legal-rag-api --timeout=5m

                # Show pod status
                kubectl get pods -l app=legal-rag-api
